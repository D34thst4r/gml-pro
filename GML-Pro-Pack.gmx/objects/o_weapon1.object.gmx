<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frame=0;
defaultSpriteRotationCorrection=90;
image_xscale=0.1;
image_yscale=0.1;
lifespan=30;
team=0;
damage=3;
heat=10;
static=5;
acid=5;
radiation=5;
ejectable=10; // 10% chance of crew ejection on impact
collision_radius=3;
collision_radius_m=3.0; // radius when at maximum size (for expanders)
shot_by=noone;
collided=noone;
colliding=noone;
sprite=s_redflare;
blend=bm_normal;
subs=sprite_get_number(sprite);
sub=0;
dsub=0;
olsprite=s_empty;
olblend=bm_normal;
oltint=c_white;
ol_follows_scale=false;
olscale=1.0;
ol_follows_alpha=true;
olalpha=1.0;
tint=c_white;
alpha=1.0;
dx=0;
dy=0;
rads=0;
cost=0;
sint=0;
creates=noone; // spawned when lifespan=0
alpha=1.0;
alphaFactor=1.0;
velocity=10.0;
decelleration=0.0;

// Triggers the end explosion of a specific pattern
fizzle_explosion=true;
fizzle_explosion_type=0;
end_explosion=true;
end_explosion_type=0;

wrapSub=true;
pingpong=false;

color=tint; // used by calculations

fadesAlpha=false; // fades the alpha portion as well as rgb portion
fadein=0;
fadeOutLength=5;
fadeout=lifespan-fadeOutLength;

// .oOOOo. expands size, and can fade alpha
expands=false;
expandFadesAlpha=true;
expanded=0;
expandtime=100; // a point of lifespan
contracttime=175; // a point of lifespan
contracts=50; // set equal to lifespan-contracttime (eg has lifespan 225)
contracted=50; // set equal to lifespan-contracttime
size=1.0;

// Its sprite rotates
spriteRotation=0.0;
spriteRotationSpin=0.0;

// Drops an instance N times, maybe looping at an interval
dropping=noone;
dropDelay=30; // frames
dropDelayRandomRange=false; // picks a random value between dropDelay and dropDelayB
dropDelayB=60; // used only when above is true
dropDirection=0.0;  // off the source
dropRandomDirection=true; // will drop in any direction
dropDirectionRange=true; // treat dropDirection as a range from general direction of object
dropDirectionRotation=0.0;  // rotates the dropDirection by a translation factor
dropRandomSpeed=true; // drops at any speed
dropSpeedFloor=0.1;
dropSpeed=1.0;
dropRelative=false; // when dropped, drops at same speed;
dropLoops=0; // # of additional times to drop
dropInterval=5; // seconds between drops, if 0, will drop a series
dropRandomizeInterval=false;
dropIntervalFloor=2;
dropIntervalCeil=10;
destroyOnLastDrop=false;  // will destroy the object when the item drops
dropSetTeam=true;  // sets the .team on the dropped object equal to this object's team
dropLoopRepeats=0; // repeats this N times
dropLoopRepeatInterval=0; // with a delay of N
dropLoopCount=0; // used by the droploop repeat feature to reset dropLoops
dropLoopRepeatRandomIntervals=false;
dropLoopRepeatRandomFloor=10;
dropLoopRepeatRandomCeil=20;

// Seeking
seekDelay=0; // delay (in frames) before bullet starts seeking
seeks=false; // if true, object seeks
seek_type=noone;  // object type it seeks
seeks_ship=true;  // seeks a ship
sticks=noone;  // if it sticks a child onto the object
seeking=noone;  // current instance target
turns=true;     // does the image_angle change with direction?
turningTo=direction; // smooth_turn info
turn_fric=0.1;
turn_accel=1.0;
turn_max_speed=6.0;
turningSpeed=0.0; // internal

// Uses shipfx thrusting system
//ai_thrust_setup(id);

// Uses shipfx lighting system
lights=0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_user(0); // Event_user(0) = Regular Step



// Note: Peter Carr and I have been trying to figure out why I cannot wrap the if.. statements here into a 
// subroutine (see collide_weapon_space.. an incomplete attempt to fix this)

///////////////// Repercussions of contact

collided=collision_circle(x,y,collision_radius,o_uberparent,true,true);
if ( collided == shot_by ) collided=noone;
if ( collided==noone ) {
 colliding=noone;
} else colliding=collided.object_index;


if ( colliding != noone ) {
 if ( collided != noone ) {
  if ( instance_exists(collided) ) {
//   if ( collided != shot_by ) {
    if ( collided.object_index == o_player ) {
     if ( collided.team != team and !collided.dying ) {
       event_user(3);
//       g_explosion(x,y,s_energy,c_red,1.0,0.3);
      instance_destroy();
     }
    } else if ( is_starship(collided.object_index) ) {
     if ( collided.team != team and !collided.dying ) {
      /*show_message(
      int(id)+" "+object_get_name(object_index)+" collides with "
      +int(collided)+" "+object_get_name(collided.object_index)
      +" colliding="+object_get_name(colliding));*/
      store_collision(id,collided,damage,heat,acid,static,radiation,direction,velocity,x,y);
       event_user(3);
//       g_explosion(x,y,s_energy,c_red,1.0,0.3);
      instance_destroy();
     }
    } else if ( collided.object_index == o_flying_space_cargo ) {
     if ( collided.scale &gt; 0.5 ) {
       event_user(3);
//       g_explosion(x,y,s_energy,c_red,1.0,0.3);
      instance_destroy();
     }
    } else if ( colliding == o_ai_gunplatform ) {
     if ( collided.team != team and !collided.dying ) {
      store_collision(id,collided,damage,heat,acid,static,radiation,direction,velocity,x,y);
       event_user(3);
//       g_explosion(x,y,s_energy,c_red,1.0,0.3);
      instance_destroy();
     }
    } else if ( collided.object_index == o_ai_asteroid ) {
     if ( !collided.dying ) {
      collided.collided=collided.id;
      collided.damage = damage;
      collided.heating = heat; 
      collided.collided_x=x;
      collided.collided_y=y;
      with ( collided ) { event_user(10); }
      if ( collided.impacted) {
       event_user(3);
//       g_explosion(x,y,s_energy,c_red,1.0,0.3);
       instance_destroy();
      }
     }
    } else if ( collided.object_index == o_g_explosion ) {
     collided=noone;
     colliding=noone;
    }
//   }
  }
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ( fizzle_explosion ) {
 var explosion;
 if ( fizzle_explosion_type == 0 ) { // red poof
  explosion=g_explosion(x,y,s_energy,c_red,1.0,0.3);
 } else if ( fizzle_explosion_type == 1 ) { // blue wisp
  explosion=g_explosion(x,y,s_energy,c_aqua,1.0,0.5);
 } else if ( fizzle_explosion_type == 2 ) { // untinted large
  explosion=g_explosion(x,y,s_energy,c_white,1.0,1,0);
 } else if ( fizzle_explosion_type == 3 ) { // ricochet
  var r;
  r=random(6);
  if ( r&lt;1 ) {
   explosion=g_explosion(x,y,s_spark1,tint,1.0,1.0);
  } else if ( r&lt;2 ) {
   explosion=g_explosion(x,y,s_spark2,tint,1.0,1.0);
  } else if ( r&lt;3 ) {
   explosion=g_explosion(x,y,s_spark3,tint,1.0,1.0);
  } else if ( r&lt;4 ) {
   explosion=g_explosion(x,y,s_spark4,tint,1.0,1.0);
  } else if ( r&lt;5 ) {
   explosion=g_explosion(x,y,s_spark5,tint,1.0,1.0);
  } else {
   explosion=g_explosion(x,y,s_spark6,tint,1.0,1.0);
  }
  explosion.framespeed=0.25;
  explosion.blend=bm_add;
  explosion.scale=0.5;
 } else if ( fizzle_explosion_type == 4 ) { // green
  explosion=g_explosion(x,y,s_energy,c_lime,1.0,0.3);
 } else if ( fizzle_explosion_type == 5 ) { // large green
  explosion=g_explosion(x,y,s_energy,c_lime,0.7,1.0);
 } else if ( fizzle_explosion_type == 3 ) { //  ricochet
  var r;
  r=random(6);
  if ( r&lt;1 ) {
   explosion=g_explosion(x,y,s_spark1,tint,1.0,1.0);
  } else if ( r&lt;2 ) {
   explosion=g_explosion(x,y,s_spark2,tint,1.0,1.0);
  } else if ( r&lt;3 ) {
   explosion=g_explosion(x,y,s_spark3,tint,1.0,1.0);
  } else if ( r&lt;4 ) {
   explosion=g_explosion(x,y,s_spark4,tint,1.0,1.0);
  } else if ( r&lt;5 ) {
   explosion=g_explosion(x,y,s_spark5,tint,1.0,1.0);
  } else {
   explosion=g_explosion(x,y,s_spark6,tint,1.0,1.0);
  }
  explosion.framespeed=0.25;
  explosion.blend=bm_add;
  explosion.scale=0.5;
 } else if ( end_explosion_type == 7 ) {
   explosion=g_explosion(x,y,s_shine2,tint,1.0,0.2);
   explosion.blend=bm_add;
   explosion.image_angle=random(360);
 } else { // tint-based (default)
  explosion=g_explosion(x,y,s_energy,tint,1.0,0.3);
 } 
 if ( valid_instance(collided) ) {
  explosion.dx=collided.dx;
  explosion.dy=collided.dy;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ( end_explosion ) {
 var explosion;
 if ( end_explosion_type == 0 ) { // red poof
  explosion=g_explosion(x,y,s_energy,c_red,1.0,0.3);
 } else if ( end_explosion_type == 1 ) { // blue wisp
  explosion=g_explosion(x,y,s_energy,c_aqua,1.0,0.5);
 } else if ( end_explosion_type == 2 ) { // untinted large
  explosion=g_explosion(x,y,s_energy,c_white,1.0,1,0);
 } else if ( end_explosion_type == 3 ) { // ricochet
  var r;
  r=random(6);
  if ( r&lt;1 ) {
   explosion=g_explosion(x,y,s_spark1,tint,1.0,1.0);
  } else if ( r&lt;2 ) {
   explosion=g_explosion(x,y,s_spark2,tint,1.0,1.0);
  } else if ( r&lt;3 ) {
   explosion=g_explosion(x,y,s_spark3,tint,1.0,1.0);
  } else if ( r&lt;4 ) {
   explosion=g_explosion(x,y,s_spark4,tint,1.0,1.0);
  } else if ( r&lt;5 ) {
   explosion=g_explosion(x,y,s_spark5,tint,1.0,1.0);
  } else {
   explosion=g_explosion(x,y,s_spark6,tint,1.0,1.0);
  }
  explosion.framespeed=0.25;
  explosion.blend=bm_add;
  explosion.scale=0.5;
 } else if ( end_explosion_type == 4 ) { // green
  explosion=g_explosion(x,y,s_energy,c_lime,1.0,0.3);
 } else if ( end_explosion_type == 5 ) { // large green
  explosion=g_explosion(x,y,s_energy,c_lime,0.7,1.0);
 } else if ( end_explosion_type == 6 ) { //  ricochet
  var r;
  r=random(6);
  if ( r&lt;1 ) {
   explosion=g_explosion(x,y,s_spark1,tint,1.0,1.0);
  } else if ( r&lt;2 ) {
   explosion=g_explosion(x,y,s_spark2,tint,1.0,1.0);
  } else if ( r&lt;3 ) {
   explosion=g_explosion(x,y,s_spark3,tint,1.0,1.0);
  } else if ( r&lt;4 ) {
   explosion=g_explosion(x,y,s_spark4,tint,1.0,1.0);
  } else if ( r&lt;5 ) {
   explosion=g_explosion(x,y,s_spark5,tint,1.0,1.0);
  } else {
   explosion=g_explosion(x,y,s_spark6,tint,1.0,1.0);
  }
  explosion.framespeed=0.25;
  explosion.blend=bm_add;
  explosion.scale=0.5;
 } else if ( end_explosion_type == 7 ) {
   explosion=g_explosion(x,y,s_shine2,tint,1.0,0.2);
   explosion.blend=bm_add;
   explosion.image_angle=random(360);
 } else { // tint-based (default)
  explosion=g_explosion(x,y,s_energy,tint,1.0,0.3);
 } 
 if ( valid_instance(collided) ) {
  explosion.dx=collided.dx;
  explosion.dy=collided.dy;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Lifespan
lifespan-=1;
if ( lifespan &lt;= 0 ) {
 if ( creates != noone )
  request_instance(creates,team,image_angle,x,y);
 event_user(4);
 instance_destroy();
} else {
 // Frame "one"
 if ( frame == 0 ) {
  if ( dropDelayRandomRange )
  dropDelay=real(int(number_range(dropDelay,dropDelayB)));
 }

 // Frame advancement
 frame+=1;

 // Decelleration
 if ( velocity &gt; 0.0 ) velocity-=decelleration;
 
 // Turning
 image_angle=direction;
 
 // Spinning
 spriteRotation+=spriteRotationSpin;

 // Move position
 rads=degtorad(-norm_deg(direction)-90.0);
 cost=cos(rads);
 sint=sin(rads);
 dx=cost*velocity;
 dy=sint*velocity;
 x+=dx;
 y+=dy;
 
 // Drop other objects
 if ( dropping != noone ) {
  if ( frame == dropDelay ) { // Triggered
   var d;
   d=instance_create(x,y,dropping);
   var v;
   if ( dropRandomSpeed ) {
    v=number_range(dropSpeedFloor,dropSpeed);
   } else {
    v=dropSpeed;
   }
   if ( dropRandomDirection ) {
    if ( dropDirectionRange ) {
     var a;
     a=dropDirectionRotation+direction+number_range(0,2*dropDirection)-dropDirection;
     d.direction=a;
     d.dx=cos(degtorad(a))*v;
     d.dy=sin(degtorad(a))*v;
    } else {
    }
   } else {
    var a;
    a=dropDirectionRotation+direction;
    d.direction=a;
    d.dx=cos(degtorad(a))*v;
    d.dy=sin(degtorad(a))*v;
   }
   if ( dropRelative ) {
    d.dx+=dx;
    d.dy+=dy;
   }
   if ( dropLoops &gt; 0 ) {
    dropLoops-=1;
    if ( dropLoops = 0 ) {
     if ( dropLoopRepeats &gt; 0 ) {
      dropLoopRepeats-=1;
      if ( dropLoopRepeats &gt;= 0 ) {
       dropLoops=dropLoopCount;
       if ( dropLoopRepeatRandomIntervals ) {
        dropDelay=frame+number_range(dropLoopRepeatRandomFloor,dropLoopRepeatRandomCeil);
       } else {
        dropDelay=frame+dropLoopRepeatInterval;
       }
      }
     }
    }
    if ( dropRandomizeInterval ) 
     dropDelay=frame+real(int(number_range(dropIntervalFloor,dropIntervalCeil)));
    else {
     if ( dropInterval &lt;= 0 ) dropInterval=1;
     dropDelay=frame+dropInterval;
    }
    if ( dropSetTeam ) d.team=team;
   }
  }
 }

 // Advance sprite frame, wrap if desired.
 sub+=dsub;
 if ( pingpong ) {
  if ( sub &gt; sprite_get_number(sprite) ) { dsub=-abs(dsub); sub=sprite_get_number(sprite); }
  else if ( sub &lt; 0 ) { dsub=abs(dsub); sub=0; }
 } else if( wrapSub ) {
  if ( sub &gt; sprite_get_number(sprite) ) sub=0;
 }

 // Scale in/out
 if ( expands ) {
  if ( frame &gt;= contracttime ) {
   contracted-=1;
   size=contracted/contracts;
  } else if ( frame &lt; expandtime ) {
    size=frame/expandtime;
  } else {
   size=1.0;
   contracted=contracts;
  }
  if ( expandFadesAlpha ) alpha=size;
  collision_radius=collision_radius_m*size;
 }

 // Fade in/out
 if ( frame &lt; fadein ) {
  var factor;
  factor=frame/fadein;
  color=
   make_color_rgb(
    red(tint)*factor,
    blue(tint)*factor,
    green(tint)*factor
   );
  if ( fadesAlpha ) alpha=factor;
 } else if ( frame &gt; fadeout ) {
  var factor;
  factor=(frame-fadeout)/fadeOutLength;
  color=
   make_color_rgb(
    red(tint)*factor,
    blue(tint)*factor,
    green(tint)*factor
   );
  if ( fadesAlpha ) alpha=factor;
 } else {
  if ( fadesAlpha ) alpha=1.0;
  color=tint;
 }

 if ( seeks ) {
  if ( seeking == noone ) {
   if ( seeks_ship ) {
    var iid,i,stop;
    stop=false;
    for ( i=0; not stop and i&lt;instance_count; i++ ) {
     iid=instance_id[i];
     if ( valid_instance(iid) ) {
      if ( is_starship(iid.object_index) ) {
       seeking=iid;
       stop=true;
      }
     }
    }
   } else if ( seek_type != noone ) {
    var iid,i;
    for ( i=0; i&lt;instance_count; i++ ) {
     iid=instance_id[i];
     if ( seek_type == iid.object_index ) {
      seeking=iid;
      break;
     }
    }
   }
  }
  if ( valid_instance(seeking) ) {
   var ta;
   ta=LineAngle(x,y,seeking.x,seeking.y)-direction;
   turningSpeed=smooth_turn(direction,ta,
    turn_accel[i],
    turn_fric,
    turn_max_speed,
    turningSpeed
   );
  }
 }

 direction+=turningSpeed;
 if ( turns ) {
  image_angle=direction+defaultSpriteRotationCorrection;
 }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// overlayed
if ( olsprite != s_empty ) {
 draw_set_blend_mode(olblend);
 if ( ol_follows_alpha ) {
  if ( ol_follows_scale ) {
   draw_sprite_ext(olsprite,0,x,y,size,size,x+y,oltint,alpha);
  } else {
   draw_sprite_ext(olsprite,0,x,y,olscale,olscale,x+y,oltint,alpha);
  }
 } else {
  if ( ol_follows_scale ) {
   draw_sprite_ext(olsprite,0,x,y,size,size,x+y,oltint,olalpha);
  } else {
   draw_sprite_ext(olsprite,0,x,y,olscale,olscale,x+y,oltint,olalpha);
  }
 }
}
// "main" animated sprite
draw_set_blend_mode(blend);
draw_sprite_ext(sprite,sub,x,y,image_xscale*size,image_yscale*size,image_angle+spriteRotation,tint,alpha*alphaFactor);
render_lights(id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
